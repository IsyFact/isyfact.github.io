<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Konzept :: IsyFact Dokumentation</title>
    <link rel="canonical" href="https://isyfact.github.io/isyfact-jsf-doku/latest/isy-web/konzept/konzept.html">
    <meta name="generator" content="Antora 3.0.1">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="stylesheet" href="../../../../_/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../../../_/css/isyfact.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://isyfact.github.io">IsyFact Dokumentation</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="isyfact-jsf-doku" data-version="5.3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="konzept.html">JavaServer Faces (JSF)</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="konzept.html">Konzept</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="anhaenge.html">Anhänge</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../nutzungsvorgaben/nutzungsvorgaben.html">Nutzungsvorgaben</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">JavaServer Faces (JSF)</span>
    <span class="version">5.3</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../glossary/latest/glossary/master.html">Glossar</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glossary/latest/glossary/master.html">1.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../isyfact-standards-doku/latest/einstieg/einstieg.html">IsyFact Standards</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../isyfact-standards-doku/latest/einstieg/einstieg.html">3.0 (DEV)</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="konzept.html">JavaServer Faces (JSF)</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="konzept.html">5.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../isyfact-style-doku/latest/isy-style/styleguide.html">Styleguide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../isyfact-style-doku/latest/isy-style/styleguide.html">5.4</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../isyfact-standards-doku/latest/einstieg/einstieg.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="konzept.html">JavaServer Faces (JSF)</a></li>
    <li><a href="konzept.html">Konzept</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Inhalt" data-levels="3">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Konzept</h1>
<div id="preamble">
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><span class="image left"><img src="../../../../glossary/latest/licence/_images/IFS-Logo.png" alt="IFS-Logo" width="150"></span> Diese Seite ist ein Teil der IsyFact-Standards.
Alle Inhalte der Seite, insbesondere Texte und Grafiken, sind urheberrechtlich geschützt.
Alle urheberrechtlichen Nutzungs- und Verwertungsrechte liegen beim Bundesverwaltungsamt.</p>
</div>
<div class="paragraph">
<p><span class="image right"><img src="../../../../glossary/latest/licence/_images/CC-BY.png" alt="Creative Commons Namensnennung" width="150"></span>
Die Nutzung ist unter den <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-cc-licence" class="xref page">Lizenzbedingungen</a> der <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-cc-short" class="xref page">Creative Commons Namensnennung 4.0 International</a> gestattet.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>Java Bibliothek / IT-System</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 20%;">
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Art</th>
<th class="tableblock halign-left valign-top">Version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isy-web</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bibliothek</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v5.3.0</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="einleitung"><a class="anchor" href="#einleitung"></a>1. Einleitung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Im Dokument <a href="../../../../isyfact-standards-doku/latest/blaupausen/referenzarchitektur-it-system/master.html" class="xref page">Softwaretechnische Architektur</a> ist der Aufbau von <a href="../../../../glossary/latest/glossary/master.html#glossar-it-system" class="xref page">IT-Systemen</a> in fünf Komponenten beschrieben.
Eine davon ist die Komponente GUI (s. <a href="#image-IFRefArcITSysGUI">Softwaretechnische Architektur eines IT-Systems (GUI hervorgehoben)</a>).</p>
</div>
<div id="image-IFRefArcITSysGUI" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/IFRefArcITSysGUI.png" alt="IFRefArcITSysGUI">
</div>
<div class="title">Abbildung 1. Softwaretechnische Architektur eines IT-Systems (GUI hervorgehoben)</div>
</div>
<div class="paragraph">
<p>Dieses Konzept baut auf dem <a href="../../../../isyfact-standards-doku/latest/blaupausen/detailkonzept-komponente-web-gui/master.html" class="xref page">Detailkonzept Web-GUI</a> auf und beschreibt die Architektur der GUI-Komponente, umgesetzt mit den Technologien JSF und Spring Web Flow.
Es enthält darüber hinaus architektonische und technische Vorgaben, die bei der Umsetzung der GUI-Komponente zu beachten sind.
Es streift Aspekte der verwendeten Technologien, wo nötig, setzt in der Breite aber eine gewisse Vorkenntnis voraus.</p>
</div>
<div class="paragraph">
<p>Ergänzend wird im Dokument <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a> die Umsetzung der GUI-Komponente mit dem JSF Frontend-Framework beschrieben.
Dort finden sich konkrete, technische Vorgaben, die bei der Umsetzung der GUI-Komponente zu beachten sind.</p>
</div>
<div class="paragraph">
<p>Zielgruppe dieses Dokuments sind Architekten, die sich einen Überblick über den Baustein JSF verschaffen und wissen möchten, welche Architekturvorgaben und Architekturentscheidungen der Baustein mit sich bringt.</p>
</div>
<div class="paragraph">
<p>Das Dokument ist in zwei Teile gegliedert.
Nach einer kurzen Einführung in die verwendeten Technologien (JSF und Spring Web Flow) beschäftigt sich das Konzept mit der Architektur einer JSF-GUI.
Dabei erläutert es zunächst den Aufbau der GUI-Komponente sowie die Kommunikation zwischen ihren Bestandteilen.
Danach stellt es die Vorgaben an die Verwendung von JSF und JavaScript vor.
Schließlich enthält es noch ein Kapitel zum Thema Session Behandlung.</p>
</div>
<div class="paragraph">
<p>Im Anhang steht eine Checkliste, die als Ausgangspunkt für die Qualitätssicherung der nach diesem Konzept umgesetzten <a href="../../../../glossary/latest/glossary/master.html#glossar-gui" class="xref page">GUIs</a> dienen soll.</p>
</div>
<div class="paragraph">
<p>Allgemeine Angaben zur Gestaltung von Oberflächen finden sich im <a href="../../../../isyfact-style-doku/latest/isy-style/styleguide.html" class="xref page">Styleguide</a>.</p>
</div>
<div class="sect2">
<h3 id="zielsetzung"><a class="anchor" href="#zielsetzung"></a>1.1. Zielsetzung des Bausteins JSF</h3>
<div class="paragraph">
<p><strong>Einfachheit der Verwendung von JSF</strong>: Hier werden die Konfiguration und der Einsatz der verwendeten Technologien festgelegt.
Dazu zählen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Einsatz von Facelets</p>
</li>
<li>
<p>Einsatz von Tag Libraries</p>
</li>
<li>
<p>Fehlerbehandlung</p>
</li>
<li>
<p>Anbindung von Hilfesystemen</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Einfachheit des Einsatzes von Spring Web Flow:</strong> Die Definition der Dialogschritte und die Abhängigkeiten zu den zugehörigen Daten für die Darstellung wird über Spring Web Flow festgelegt.
Hierzu werden folgende Themenbereiche genauer definiert:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Konfiguration der Dialog Abläufe (Flow)</p>
</li>
<li>
<p>Anbindung der Backend-Services (Spring Beans)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Einfachheit des Session-Managements:</strong> Hier wird definiert, wie die Behandlung von Session Informationen erfolgen soll und welche wiederverwendbaren Services zur Verfügung gestellt werden.</p>
</div>
</div>
<div class="sect2">
<h3 id="sicherheitsanforderungen"><a class="anchor" href="#sicherheitsanforderungen"></a>1.2. Sicherheitsanforderungen</h3>
<div class="paragraph">
<p>Web-Anwendungen sind besonderen Gefährdungen ausgesetzt.
Folgende Anforderungen müssen bei der Entwicklung von Web-Anwendungen berücksichtigt werden:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Entwickler müssen sich mit den TOP10 Risiken für Web-Anwendungen gemäß OWASP vertraut machen (siehe <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-owasp" class="xref page">OWASP Top 10</a>)</p>
</li>
<li>
<p>Vertrauliche Informationen dürfen nicht als GET-Parameter übermittelt werden.
Dies verhindert, dass solche Informationen ungewollt in Log-Dateien, Caches usw.
gespeichert werden.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basistechnologien"><a class="anchor" href="#basistechnologien"></a>2. Einführung in die Basistechnologien</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Die Übersicht der Basistechnologien soll dem Leser einen einfacheren Einstieg in die angewendeten Frameworks und Technologien ermöglichen.
Zusätzlich findet sich noch ein Verweis auf die konkret eingesetzten Implementierungen.
Hierbei werden auch Architekturprinzipien angesprochen, welche in den Technologien Verwendung finden.</p>
</div>
<div class="paragraph">
<p>Für detaillierte Informationen über die verwendeten Technologien sei auf entsprechende Literatur verwiesen: <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-jsf-wiki" class="xref page">JavaServer Faces</a>, <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-swf" class="xref page">Spring Web Flow</a> und <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-spring" class="xref page">Spring</a>.</p>
</div>
<div class="sect2">
<h3 id="jsf-facelets"><a class="anchor" href="#jsf-facelets"></a>2.1. JSF / Facelets</h3>
<div class="paragraph">
<p><strong>Java Server Faces (JSF)</strong> ist ein Framework für die Entwicklung von Webanwendungen.
Es basiert auf einer MVC-Architektur.
Der Schwerpunkt von JSF ist die Bereitstellung grafischer Komponenten wie z.B. Tabellen, Formulare, Kalender, Menüs oder Editoren für die Entwicklung von Webanwendungen.
Das zentrale Konzept hinter JSF ist die Erstellung eines Komponentenbaumes aus diesen grafischen Komponenten.
Aus diesem Komponentenbaum wird schließlich die auszuliefernde HTML-Seite generiert.</p>
</div>
<div class="paragraph">
<p>Die IsyFact setzt die Referenzimplementierung von Oracle (<a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-javaserver-faces" class="xref page">JavaServer Faces</a>) ein und erweitert diese im Bereich der Komponenten um die Bibliothek <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-tomahawk" class="xref page">Apache Tomahawk</a>.</p>
</div>
<div class="paragraph">
<p><strong>Facelets</strong> ist eine Template-Engine und die Standard-View-Technologie von JSF.
Facelets löst in dieser Funktion JSP ab.
Mit Facelets werden kleine, wiederverwendbare <a href="../../../../glossary/latest/glossary/master.html#glossar-gui" class="xref page">GUI</a>-Komponenten erstellt, die durch ein entsprechendes XML-Tag in eine Seite inkludiert werden.
Hierbei wird der Templating-Mechanismus der Facelets verwendet.
Die Ablage erfolgt in XHTML-Dokumenten.
Im Gegensatz zu Taglibs erfolgt ein Include der Komponente und kein Aufruf von Java-Code für die Generierung von gerendertem GUI-Code.</p>
</div>
<div class="paragraph">
<p>Facelets bieten vielfältige Möglichkeiten, Vorlagenfragmente zu einer Gesamtseite zusammenzusetzen, um z.B. auf jeder Seite einen einheitlichen Seitenrahmen zu realisieren.
Weiter können Facelets mit herkömmlichen HTML-Editoren bearbeitet werden und sind somit einfacher zu verstehen und zu editieren.
Als Implementierung kommt wiederum die Referenzimplementierung von Oracle (<a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-javaserver-faces" class="xref page">JavaServer Faces</a>) zum Einsatz.</p>
</div>
<div class="sect3">
<h4 id="bearbeitungsmodell-einer-jsf-anfrage"><a class="anchor" href="#bearbeitungsmodell-einer-jsf-anfrage"></a>2.1.1. Bearbeitungsmodell einer JSF Anfrage</h4>
<div class="paragraph">
<p>Die Spezifikation der Java Server Faces definiert einen sogenannten Lebenszyklus <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-jsf-wiki" class="xref page">JavaServer Faces</a>, den eine JSF-Anwendung mit jedem Aufruf erneut durchläuft.
Dieser Lebenszyklus ist in sechs <em>Phasen</em> (englisch <em>Phases</em>) aufgeteilt.</p>
</div>
<div id="image-PhasemodJSF" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/jsf-phasen.png" alt="jsf phasen">
</div>
<div class="title">Abbildung 2. Phasenmodell JSF</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Restore View</em> („Sicht wiederherstellen“) wählt anhand der eingehenden Anforderung eine Sicht (<em>View</em>) aus und baut den dazu passenden Komponentenbaum bei Bedarf auf.</p>
</li>
<li>
<p><em>Apply Request Values</em> („Anforderungsparameter anwenden“) extrahiert Parameter aus der Anforderung (üblicherweise ein HTTP-Post-Request) und weist sie den passenden JSF-Komponenten zu, beispielsweise Eingabefeldern.</p>
</li>
<li>
<p><em>Process Validations</em> („Validierung ausführen“) überprüft die Gültigkeit der zuvor ermittelten Eingaben.
Dazu werden eigene Validator-Objekte verwendet, die den Komponenten in der View-Definition zugewiesen wurden.</p>
</li>
<li>
<p><em>Update Model Values</em> („Modell aktualisieren“) weist den Modellobjekten die zuvor ermittelten Werte zu.</p>
</li>
<li>
<p><em>Invoke Application</em> („Anwendung aufrufen“) ruft durch die Anwendung definierte Methoden auf, beispielsweise wenn ein Button betätigt wurde.</p>
</li>
<li>
<p><em>Render Response</em> („Antwort wiedergeben“) erzeugt schließlich die Antwort auf die ursprüngliche Anfrage, beispielsweise eine HTML-Seite.
Hierzu werden sogenannte <em>Renderer</em> aufgerufen, die den View-Komponenten zugeordnet sind.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Treten Fehler auf oder soll als Antwort beispielsweise eine HTML-Seite aufgerufen werden, die keine JSF-Komponenten enthält, so können einzelne Phasen übersprungen werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="datenmodell"><a class="anchor" href="#datenmodell"></a>2.1.2. Datenmodell</h4>
<div class="paragraph">
<p>Die Daten für die Visualisierung in JSF werden in Model Beans gehalten.
Hierfür wird nicht auf den durch JSF zur Verfügung gestellten Mechanismus der Managed Beans zurückgegriffen.
Das Datenmodell wird über Spring Web Flow direkt aus Model Beans verfügbar gemacht.
Damit ist die Verwaltung des Models unter Kontrolle des Dialogflusses, der über Spring Web Flow gesteuert wird.
Die einem Flow zugeordneten Model Beans werden durch den Flow instanziiert und unterliegen somit dem Flow-Lebenszyklus.</p>
</div>
</div>
<div class="sect3">
<h4 id="facelets"><a class="anchor" href="#facelets"></a>2.1.3. Facelets</h4>
<div class="paragraph">
<p>Mit den Facelets werden das visuelle Layout und die Controls für die Ansicht im Browser definiert.
Durch die Nähe zu HTML sind schnell die notwendigen Ansichten designt und können getestet werden.
Das Mapping der Controls auf die Daten geschieht über die in JSF verwendete Expression Language (EL).
Mit der EL werden direkt die Attribute des zugehörigen Beans genutzt.</p>
</div>
<div class="paragraph">
<p>Ein weiterer Vorteil von Facelets ist die Verwendung von Templates.
Durch diese ist es möglich, bereits einen zum <a href="../../../../isyfact-style-doku/latest/isy-style/styleguide.html" class="xref page">Styleguide</a> konformen Rahmen zur Verfügung zu stellen, in welchen die
Applikation lediglich durch definierte Einfügungen ihre Inhalte einbetten.</p>
</div>
</div>
<div class="sect3">
<h4 id="taglibs"><a class="anchor" href="#taglibs"></a>2.1.4. Taglibs</h4>
<div class="paragraph">
<p>Durch den Einsatz von Facelets ist die direkte Einbettung von Tag Libraries nicht möglich.
Vielmehr müssen diese noch separat mit einer Deskription versehen werden, aus welcher die einzelnen Tags
ersichtlich sind und ihr Mapping auf die zugehörigen Klassen definiert ist.</p>
</div>
<div class="paragraph">
<p>Für den Einsatz der myFaces Tomahawk Library wird eine entsprechende Konfiguration zur Verfügung gestellt.
Der Einsatz dieser Library unterliegt für den Einsatz in der IsyFact der allgemeinen Einschränkung bei der Verwendung von JavaScript (siehe auch <a href="../nutzungsvorgaben/nutzungsvorgaben.html#benoetigte-bibliotheken" class="xref page">Benötigte Bibliotheken</a> in den Nutzungsvorgaben).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-web-flow"><a class="anchor" href="#spring-web-flow"></a>2.2. Spring Web Flow</h3>
<div class="paragraph">
<p>Spring Web Flow ist ein Framework für die Ablaufsteuerung von Anwendungsfällen innerhalb von Web-Anwendungen.
Ein solcher „Flow“ innerhalb von Spring Web Flow ist eine Abfolge zusammenhängender Masken, wie z.B. das Durchlaufen der Schritte zur Registrierung eines neuen Benutzers in einer Web-Anwendung.</p>
</div>
<div class="paragraph">
<p>Ein erklärtes Ziel von Spring Web Flow ist die Unterstützung der Browser-Navigation, die in der Web-Entwicklung immer wieder zu Problemen führt.
Das Framework übernimmt dabei die Navigation zwischen den einzelnen Views und stellt darüber hinaus einen eigenen Scope Container für Model Beans zur Verfügung.
Dieser erweitert die Web-Anwendung um die folgenden Scopes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Flash: Gültig, solange der Flow aktiv ist, jedoch werden Flash Scope Beans nach jedem View-State geleert und dienen somit dazu, Daten zwischen zwei User Events zu transferieren.</p>
</li>
<li>
<p>Flow: Steht über die gesamte Laufzeit des Flows zur Verfügung.</p>
</li>
<li>
<p>Conversation: Die Lebensdauer ist mit dem Flow Scope identisch, nur stehen Conversation Scope Beans auch in den zugehörigen Subflows zur Verfügung.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Web Flow implementiert im Kern einen finiten Zustandsautomaten, der auf definierte Anfangs- und Endzustände angewiesen ist.</p>
</div>
<div class="paragraph">
<p>Der Ablauf der logisch zusammenhängenden Views wird in einem sogenannten Flow definiert.
Innerhalb eines Flows stehen verschiedene States zur Verfügung.
Zunächst muss jeder Flow einen Start State und einen End State besitzen.
Der Start State definiert den Einstiegspunkt und aktiviert den jeweiligen Flow.
Dieser bleibt so lange aktiv, bis ein End State erreicht wird.</p>
</div>
<div class="paragraph">
<p>Wie bereits erwähnt, setzt sich Spring Web Flow das Ziel, die Browser-Navigation mit „Back-/Forward-Button“ zu unterstützen.
Um diese Funktionalität zu gewährleisten, muss die Möglichkeit bestehen, den Zustand einer View zu speichern und wieder abzurufen.
Hierfür steht ein sogenanntes Repository zur Verfügung, welches die Zustände der einzelnen Views innerhalb eines Flows zwischenspeichert.
Dadurch kann man den Zustand jeder View innerhalb eines Flows zu einem beliebigen Zeitpunkt reproduzieren.</p>
</div>
<div class="sect3">
<h4 id="flows-subflows"><a class="anchor" href="#flows-subflows"></a>2.2.1. Flows / Subflows</h4>
<div class="paragraph">
<p>Ein Flow kann wahlweise als XML-Datei oder mittels der Java-API realisiert werden.
Ein Flow besteht in der Regel aus mehreren Zuständen (innerhalb von Web Flow als States bezeichnet), die nacheinander und in Abhängigkeit von der jeweiligen Benutzerinteraktion durchlaufen werden.</p>
</div>
<div class="paragraph">
<p>Auch die Modularisierung von Flows in kleine Einheiten ist durch sogenannte Subflows bzw.
Inline-Flows ohne weiteres möglich.
Ein Subflow wird wie jede andere Flow-Definition erstellt.
Der Unterschied zu einem normalen Flow liegt lediglich darin, dass der Subflow innerhalb eines Flows aufgerufen wird.
Eine Flow-Definition kann beliebig viele Subflows enthalten, welche wiederum weitere Subflows aufrufen können.</p>
</div>
</div>
<div class="sect3">
<h4 id="back-button-handling"><a class="anchor" href="#back-button-handling"></a>2.2.2. Back-Button Handling</h4>
<div class="paragraph">
<p>Während der Ausführung von Flows werden die Variablen mit einer Zwischenspeicherung in das Repository geschrieben.
Hierbei wird immer, wenn ein Flow durch eine User-Interaktion unterbrochen wird, der aktuelle Status gespeichert.
Das Repository liefert diesen bei der Fortsetzung des Flows zurück.
Der dafür notwendige „Flow-Execution-Key“, der Schlüssel, der zur Identifikation des aktuellen Flow-Status dient,
wird hierbei von Spring Web Flow erzeugt.</p>
</div>
<div class="paragraph">
<p>Dieses Speichern des Status von vorhergehenden Schritten im Flow unterstützt so in Kombination mit
einem „Post Redirect Get“ Mechanismus (PRG-Pattern) die Nutzung des Back-Buttons im Browser.
Da jeder Request im Flow einen eindeutigen Execution Key an den Server sendet, kann, wenn man im
Flow zurückgeht, auch der alte Status zum Zeitpunkt dieses Request angezeigt werden, selbst wenn der Server von dem Click auf den Back-Button selbst nichts mitbekommt.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaktionsbehandlung"><a class="anchor" href="#transaktionsbehandlung"></a>2.3. Transaktionsbehandlung</h3>
<div class="paragraph">
<p>Die <a href="../../../../glossary/latest/glossary/master.html#glossar-gui" class="xref page">GUI</a>-Komponente und der <a href="../../../../glossary/latest/glossary/master.html#glossar-anwendungskern" class="xref page">Anwendungskern</a> sind Teil derselben Web-Applikation und werden per Spring-Konfiguration miteinander verbunden.</p>
</div>
<div class="paragraph">
<p>Oft gibt es den Fall, dass über die GUI eine Aktion in einer anderen Anwendung ausgelöst werden soll.
Ein Beispiel dafür ist die GUI einer <a href="../../../../glossary/latest/glossary/master.html#glossar-geschaeftsanwendung" class="xref page">Geschäftsanwendung</a> zur Datenerfassung, wobei die Speicherung der Daten über einen Service einer anderen Fachanwendung implementiert ist.
In diesem Fall enthält der Anwendungskern der Fachanwendung zur Datenerfassung nur wenig Funktionalität: in ihm werden die Daten für den Serviceaufruf der nachgelagerten Fachanwendung aufbereitet und der Serviceaufruf selbst durchgeführt.
Wichtig in diesem Fall ist, dass es nach Zielarchitektur keine Transaktionen über Serviceaufrufe hinweg gibt.</p>
</div>
<div class="paragraph">
<p>In diesem Abschnitt wird die Behandlung von Transaktionen innerhalb einer Anwendung beschrieben.
Grundregel dabei ist, dass der Anwendungskern die Transaktionssteuerung übernimmt.
Aus Sicht der GUI-Komponente bedeutet dies, dass jeder Aufruf des Anwendungskerns unmittelbar eine Änderung der Daten zufolge hat.
Dabei muss die GUI-Komponente die Brücke schlagen zwischen der <em>fachlichen Transaktion</em>, die dem Nutzer dargestellt wird und der <em>technischen Transaktion,</em> die in der Datenbank abgebildet wird.</p>
</div>
<div class="paragraph">
<p>Die fachliche Transaktion entspricht einem Dialogablauf.
Ein Beispiel dafür: Der Nutzer kann in der Regel über mehrere Masken hinweg Daten eingeben.
Abschließend drückt er in einem Dialog den „OK“- bzw. den „Abbrechen“-Button.
Für den Nutzer ist klar, dass alle die von ihm eingegebenen Daten im Sinne einer Transaktion behandelt werden müssen, d.h. sie werden entweder vom System komplett übernommen oder komplett verworfen.</p>
</div>
<div class="paragraph">
<p>Aus technischer Sicht ist die Behandlung dieses Ablaufs etwas komplizierter: Die Daten, die der Nutzer in den verschiedenen Dialogen eingibt, müssen zunächst zwischengespeichert werden, bevor dann bei Betätigung eines Buttons die technische Transaktion in der Datenbank erfolgt.
Das Zwischenspeichern der Werte benötigt allerdings ebenfalls technische Transaktionen.
Da der Prozess der Web-Anwendung zustandslos ist, muss das Zwischenspeichern ebenfalls in der Datenbank erfolgen.
Hier muss die GUI zusätzliche Transaktionen durchführen.</p>
</div>
<div class="paragraph">
<p>Bei der Spring Web Flow Integration wurde ein Mechanismus verwendet, um die Zwischenwerte und Informationen zum Dialogablauf in der Datenbank abzulegen.
Das Zwischenspeichern erfolgt grundsätzlich in einer separaten Transaktion.
Somit beeinflussen sich die fachliche Transaktion und die technischen Transaktionen nicht.</p>
</div>
<div class="paragraph">
<p>Mit den technischen Transaktionen ist es jetzt möglich, „Sitzungen“ abzubilden.
Eine Sitzung ist letztendlich die Summe aller Zwischendaten, die der Nutzer eingegeben hat oder die das System selbst erzeugt hat (z.B. interne Zustände, Nutzerinformationen, &#8230;&#8203;).
Innerhalb einer Sitzung werden mehrere fachliche Transaktionen durchgeführt.</p>
</div>
<div class="paragraph">
<p>Das technische Mittel zur Repräsentation einer Sitzung ist zunächst einmal die Session des Servers.
Diese Session ist transient.
Da der Serverprozess zustandslos ist, muss sie in der Datenbank persistiert werden.
Dazu gibt es zwei Alternativen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Serialisierung der Session nach Beendigung des Request und Wiederherstellung bei neuerlichem Aufruf</p>
</li>
<li>
<p>Speichern des Spring Web Flow State an den durch Spring Web Flow vorgesehenen Hooks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Variante der Session Serialisierung ist zwar einfacher, beinhaltet aber auch eine wesentliche Gefahr.
Die Session des Servers wird zum Speichern von verschiedensten Daten genutzt, der Zugriff auf sie ist frei möglich.
Dies führt in der Praxis dazu, dass unkontrolliert große Datenmengen in der Session abgelegt werden.
Diese großen Datenmengen lassen sich dann nicht mehr effizient persistieren.
Daher wurde diese Option in der <a href="../../../../isyfact-standards-doku/latest/blaupausen/referenzarchitektur/master.html" class="xref page">Referenzarchitektur</a> ausgeschlossen.
Die Details dazu, wie in Spring Web Flow die zu speichernden Daten einer Session ermittelt werden, finden sich in Kapitel <a href="#session-behandlung">Session Behandlung</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jquery"><a class="anchor" href="#jquery"></a>2.4. JQuery</h3>
<div class="paragraph">
<p>JQuery ist ein JavaScript-Framework, das auf einfache Weise JavaScript-Funktionen bereitstellt, die insbesondere auf die grafische Gestaltung einer Oberfläche benötigt werden.
Erklärtes Ziel ist es, die Oberfläche durch den Einsatz von JavaScript eleganter nutzbar zu machen.
Besonderer Fokus liegt dabei auf den Sicherheitsaspekten, die eine Aktivierung von JavaScript mit sich bringt.
Die Oberfläche muss jedoch auch mit deaktiviertem JavaScript mit Komforteinschränkungen nutzbar sein.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architektur"><a class="anchor" href="#architektur"></a>3. Architektur einer JSF-GUI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Die Architektur von <a href="../../../../glossary/latest/glossary/master.html#glossar-gui" class="xref page">GUIs</a> mit JSF und Spring Web Flow hält sich an die Vorgaben aus der <a href="../../../../isyfact-standards-doku/latest/blaupausen/referenzarchitektur/master.html" class="xref page">Referenzarchitektur</a> sowie die architektonischen Vorgaben aus dem <a href="../../../../isyfact-standards-doku/latest/blaupausen/detailkonzept-komponente-web-gui/master.html" class="xref page">Detailkonzept Web-GUI</a>.
Sie besitzt, aufgrund der Vorgaben und der eingesetzten Technologien, folgende Eigenschaften:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nutzung des MVC-Patterns</p>
</li>
<li>
<p>Trennung des Dialogs in Dialogsteuerung und Präsentation</p>
</li>
<li>
<p>Dialogsteuerung über Spring Web Flow</p>
</li>
<li>
<p>Bildung von gekapselten GUI-Komponenten über Facelets</p>
</li>
<li>
<p>Präsentation über JSF und Facelets</p>
</li>
<li>
<p>Verwaltung von Sessions mit Spring Web Flow</p>
</li>
<li>
<p>Interaktive Oberflächenelemente mit JQuery</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#image-aufbau-gui-komponente">Aufbau einer Web-GUI mit JSF und Spring Web Flow</a> zeigt den Aufbau einer Web-GUI mit JSF und Spring Web Flow und verdeutlicht die Integration der Technologien in die Architektur.</p>
</div>
<div id="image-aufbau-gui-komponente" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/aufbau-gui-komponente.png" alt="aufbau gui komponente">
</div>
<div class="title">Abbildung 3. Aufbau einer Web-GUI mit JSF und Spring Web Flow</div>
</div>
<div class="paragraph">
<p>Im Rahmen der Anwendungsentwicklung sind die gelb hervorgehobenen Teile bereitzustellen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definition der Dialogabläufe als Flow</p>
</li>
<li>
<p>Model und Controller-Beans zur Bereitstellung der UI-Models und der UI-Logik</p>
</li>
<li>
<p>Facelets zur Visualisierung der Masken</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die grau hinterlegten Teile werden durch die IsyFact konfiguriert und bereitgestellt.</p>
</div>
<div class="sect2">
<h3 id="aufbau-gui-komponente"><a class="anchor" href="#aufbau-gui-komponente"></a>3.1. Aufbau der GUI-Komponente</h3>
<div class="paragraph">
<p>Wie im <a href="../../../../isyfact-standards-doku/latest/blaupausen/detailkonzept-komponente-web-gui/master.html" class="xref page">Detailkonzept Web-GUI</a> beschrieben, besteht die GUI-Komponente aus Dialog-Komponenten und einem gemeinsamen AWK-Wrapper.
Der Schnitt der Komponenten ist fachlich motiviert und in der Systemspezifikation beschrieben.</p>
</div>
<div class="paragraph">
<p>Die Dialog-Komponenten einer GUI-Komponente können einen gemeinsamen AWK-Wrapper und in ihren Modellen gemeinsame Klassen verwenden.
Trotzdem sind die Dialog-Komponenten zu kapseln, d.h. Controller und UI-Models dürfen nicht gemeinsam verwendet werden (siehe <a href="#image-innensicht-gui-komponente">Innensicht einer GUI-Komponente mit ihren Dialog-Komponenten</a>).</p>
</div>
<div id="image-innensicht-gui-komponente" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/innensicht-gui-komponente.png" alt="innensicht gui komponente">
</div>
<div class="title">Abbildung 4. Innensicht einer GUI-Komponente mit ihren Dialog-Komponenten</div>
</div>
<div class="paragraph">
<p>Zentral ist also die Forderung, dass die Elemente jeder Dialog-Komponente (Flow, Controller, Model und View) in definierter Weise ausschließlich untereinander kommunizieren und Zugriffe auf Elemente anderer Dialog-Komponenten unterbleiben.
<a href="#image-kommunikation-innerhalb-gui-komponente">Kommunikation innerhalb einer Dialog-Komponente</a> zeigt die Kommunikation innerhalb einer Dialog-Komponente.</p>
</div>
<div id="image-kommunikation-innerhalb-gui-komponente" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/kommunikation-innerhalb-gui-komponente.png" alt="kommunikation innerhalb gui komponente">
</div>
<div class="title">Abbildung 5. Kommunikation innerhalb einer Dialog-Komponente</div>
</div>
<div class="sect3">
<h4 id="flows"><a class="anchor" href="#flows"></a>3.1.1. Flows</h4>
<div class="paragraph">
<p>Jede GUI-Komponente wird durch einen Flow beschrieben.
Dieser definiert das Zustandsmodell der Komponente und hat die Funktion des zentralen Controllers für diese Komponente.
Er erfüllt die folgenden Aufgaben:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Erzeugung und Verwaltung eines (ggf. auch mehrerer) Model Beans</p>
</li>
<li>
<p>Definition des Flow-Ablaufs in Form eines Zustandsautomaten mit Zuständen und Zustandsübergängen (Flow, Subflows, Decision-States, Action-States, Event-Handlers)</p>
</li>
<li>
<p>Anbinden des Views</p>
</li>
<li>
<p>Steuerung der Verarbeitung im Rahmen von Zustandsübergängen</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Der Flow-Aufbau wird so gestaltet, dass im Flow alle Zustände, Zustandsübergänge sowie Aufrufe von Verarbeitungslogik zentral gebündelt werden und Ablauf und Verhalten des Flows für den Entwickler klar nachvollziehbar sind.</p>
</div>
<div class="paragraph">
<p>Der Flow wird als XML-Datei im Ordner der Komponente hinterlegt.</p>
</div>
</div>
<div class="sect3">
<h4 id="controller"><a class="anchor" href="#controller"></a>3.1.2. Controller</h4>
<div class="paragraph">
<p>Das Controller-Bean ist ein vom Komponenten-Flow aufzurufendes <strong>zustandsloses</strong> Spring Bean,
welches Änderungen an den Daten des Models vornimmt oder diese aufbereitet bzw.
Services des Anwendungskern-Wrappers aufruft.
Das Model Bean wird dem Controller mit jedem Aufruf übergeben.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Die Implementierung des Controllers ist zustandslos und stellt nur Methoden bereit.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Das Controller-Bean wird im Spring IoC-Container mit Singleton Scope erzeugt und konfiguriert.</p>
</div>
<div class="paragraph">
<p>Das Controller-Bean wird vom Flow per Expression-Language aufgerufen.
In bestimmten Fällen (siehe Abschnitt <a href="#views">Views</a>) wird ein Controller-Bean auch in einer Action (oder ActionListener) des
Komponenten-View aufgerufen.</p>
</div>
</div>
<div class="sect3">
<h4 id="models"><a class="anchor" href="#models"></a>3.1.3. Models</h4>
<div class="paragraph">
<p>Das Model Bean ist ein Datenobjekt (einfaches POJO) und hält die Daten einer GUI-Komponente.
Es hat keine Abhängigkeiten zu View, Controller oder <a href="../../../../glossary/latest/glossary/master.html#glossar-anwendungskern" class="xref page">Anwendungskern</a> und enthält im Regelfall keine Logik.
Das Model Bean wird durch den Flow erzeugt (durch Definition einer Web-Flow-Variablen) und ist somit automatisch im View sichtbar.</p>
</div>
<div id="listing-CreaModinFlow" class="listingblock">
<div class="title">Listing 1. Erzeugung einer Model-Instanz im Flow</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;flow&gt;
  &lt;!-- Erzeuge das Model zur Benutzung durch diesen Flow. --&gt;
  &lt;var name="erstellenModel"
    class="de.msg.terminfindung.gui.terminfindung.erstellen.ErstellenModel" /&gt;
&lt;/flow&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Der View liest die Daten zur Präsentation der Webseite aus dem Model Bean.
Dies können Informationen zur Ansicht aber auch änderbare Formularinhalte sein.
Werden Formularinhalte in Form eines Post-Requests auf den Server gesendet, so sorgt JSF eigenständig dafür, dass die Formularinhalte in das Model Bean rückübertragen werden.</p>
</div>
<div class="paragraph">
<p>Da das Model Bean durch den Flow erzeugt wird und Flow Scope besitzt, wird es automatisch mit in die Session-Persistierung einbezogen.
Dazu muss das Model das Interface Serializable implementieren.
Die Daten des Models werden bei den Dialogschritten eines Flows zwischen Client (Browser) und Server transparent für den Entwickler abgeglichen.</p>
</div>
<div class="paragraph">
<p>Das Model Bean ist nicht mit den JPA-Datenobjekten verbunden.
Das Schreiben in das Model bewirkt also zunächst keine Änderung in der Datenbank.
Die Persistenz fachlicher Datenobjekte wird über das Controller-Bean ausgelöst, welches über Methodenaufrufe des Anwendungskern-Wrappers fachliche Daten persistiert.</p>
</div>
<div class="paragraph">
<p>Der Abgleich von Model Beans mit einer View und das Abspeichern der Daten einer Model Bean wird im Kapitel "Erstellung der Models" in <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a> genauer beschrieben.</p>
</div>
</div>
<div class="sect3">
<h4 id="views"><a class="anchor" href="#views"></a>3.1.4. Views</h4>
<div class="paragraph">
<p>Der Komponenten-View präsentiert die Daten der Anwendung in Form von generierten HTML-Seiten.
Dazu werden ein oder mehrere Facelets verwendet, die mittels JSF-HTML-Tags auf das Model Bean der Komponente
zugreifen, um die Daten in den View einzubinden.
Da das Model Bean seine Datenzugriffsmethoden nach dem Bean-Standard (<code>get</code>/<code>set</code>/<code>is</code>) anbietet, kann mittels
Value-Expressions (z.B. <code>#{teilnehmenModel.terminfindung.tage}</code>) direkt auf Eigenschaften des Model Beans und
enthaltener Objekte zugegriffen werden.
Ein View kann auch auf mehrere zum Flow gehörende Model Beans zugreifen.</p>
</div>
<div class="paragraph">
<p>Im View können Actions definiert sein (z.B. Submit durch einen Command-Button). Dabei werden nur Action-Tokens
(String, der die Aktion benennt) übergeben, die dann im Flow entgegengenommen werden und dann Methodenaufrufe auf dem Controller auslösen.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Aus einer Aktion des Views sollte i.d.R. immer ein Zustandstoken zur Steuerung von Transitionen im Flow erzeugt werden.
Dies ist vor allem bei Maskenübergängen und fachlichen Aktionen zu verwenden.<br>
<strong>Beispiel:</strong> Suche in einem Formular, Öffnen der Detailansicht.</p>
</div>
<div class="paragraph">
<p>Aktionen, welche zur Steuerung der Darstellung innerhalb einer Maske verwendet werden, müssen nicht zwingend eine Transition auslösen.
In diesen Fällen darf der Controller direkt aufgerufen werden.<br>
<strong>Beispiel:</strong> Selektion eines Elements und darauf basierende Anpassung der Maske.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Die View-Erstellung wird im Kapitel "Erstellung der Views" in <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a> genauer beschrieben.</p>
</div>
</div>
<div class="sect3">
<h4 id="schnittstellen-zwischen-komponenten"><a class="anchor" href="#schnittstellen-zwischen-komponenten"></a>3.1.5. Schnittstellen zwischen Dialog-Komponenten</h4>
<div class="paragraph">
<p>Wie in <a href="#aufbau-gui-komponente">Aufbau der GUI-Komponente</a> beschrieben, müssen die Dialog-Komponenten voneinander gekapselt sein.
Wenn zwei Dialog-Komponenten Informationen austauschen müssen, darf dies nicht über ein gemeinsam genutztes UI-Model geschehen.
Der Austausch von Informationen erfolgt stattdessen über Input/Output-Elemente im Flow, die aus dem Model einer Dialog-Komponente gelesen oder geschrieben werden.</p>
</div>
<div class="paragraph">
<p>Ist ein Subflow B mit Daten aus dem aufrufenden Flow A zu versorgen, so bekommt dieser nicht das Model A, sondern eine Kopie eines einzelnen Objekts aus Model A übergeben.
Dies kann auch eine Datenstruktur, darf aber niemals das gesamte Model A sein.
Es ist wichtig, dass eine Kopie übergeben wird, damit Flow B nicht Teile des Models A absichtlich oder versehentlich ändert.</p>
</div>
<div class="paragraph">
<p>Besteht Bedarf, dass ein Subflow B an den aufrufenden Flow A Daten zurückgibt, so erfolgt dies über ein Output-Element.
Hier gilt analog, dass nicht das gesamte Model B, sondern lediglich Kopien eines Teils des Models übergeben werden.</p>
</div>
<div class="paragraph">
<p>Das folgende Beispiel zeigt wie ein Flow an einen Subflow Parameter übergibt und von diesem einen Ausgabewert empfängt.</p>
</div>
<div id="listing-InfoExFaufF1" class="listingblock">
<div class="title">Listing 2. Informationsaustausch zwischen Flows – aufrufender Flow</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;subflow-state id="loeschenViewState" subflow="loeschenFlow"&gt;
  &lt;input name="terminfindung"
         value="verwaltenController.kopiereTerminfindungModel()"/&gt;
  &lt;output name="loeschenTerminfindung"/&gt;
  &lt;transition on="finished" to="verwaltenViewState"&gt;
    &lt;evaluate expression="verwaltenModel.setTerminfindung(loeschenTerminfindung)"/&gt;
  &lt;/transition&gt;
&lt;/subflow-state&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Innerhalb des Subflows werden übergebene Parameter entgegengenommen und verarbeitet.
Im Endzustand wird ein Rückgabewert zurückgegeben.</p>
</div>
<div id="listing-InfoExFaufF2" class="listingblock">
<div class="title">Listing 3. Informationsaustausch zwischen Flows – aufgerufener Flow</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;flow&gt;
  &lt;input name="terminfindung" type="de.msg.terminfindung.gui.terminfindung.model.TerminfindungModel"/&gt;
  &lt;on-start&gt;
    &lt;evaluate expression="loeschenModel.setTerminfindung(terminfindung)"/&gt;
  &lt;/on-start&gt;
  &lt;view-state id="loeschenViewState"&gt;
    &lt;on-entry&gt;
      &lt;evaluate expression="loeschenController.setzeAuswahlZurueck(loeschenModel)"/&gt;
    &lt;/on-entry&gt;
    &lt;transition on="cancel" to="finished"/&gt;
    &lt;transition on="delete" to="loeschenViewState"&gt;
      &lt;evaluate expression="loeschenController.loescheZeitraeume(loeschenModel)"/&gt;
    &lt;/transition&gt;
  &lt;/view-state&gt;

  &lt;end-state id="finished"&gt;
    &lt;output name="loeschenTerminfindung"
            value="loeschenModel.getTerminfindung()"/&gt;
  &lt;/end-state&gt;
&lt;/flow&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zur Datenübergabe können auch mehrere Input- und mehrere Output-Elemente verwendet werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="_zugriff_auf_querschnittliche_controller"><a class="anchor" href="#_zugriff_auf_querschnittliche_controller"></a>3.1.6. Zugriff auf querschnittliche Controller</h4>
<div class="paragraph">
<p>Für die Steuerung des Vorgabelayouts (z.B. Menüleiste, Linksnavigation, Hilfezugriff) sowie der Nutzung von vorgegebenen Funktionen (z.B. Validierung) werden querschnittliche Controller mit zugehörigen Models verwendet.
Die Instanziierung übernimmt dabei ein übergeordneter Parent-Flow.
So kann z.B. die Seitentoolbar konfiguriert oder ein Quicklink hinzugefügt werden.</p>
</div>
<div class="paragraph">
<p>Der Aufruf dieser Controller ist generell erlaubt.
Die Controller sind als Spring Beans global verfügbar.
Welche Controller im Detail (LinksnavigationController, QuicklinksController, ValidierungsController, &#8230;&#8203;) für das Vorgabelayout verfügbar sind, wird im Dokument <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a> beschrieben.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_vorgaben_zur_verwendung_von_jsf"><a class="anchor" href="#_vorgaben_zur_verwendung_von_jsf"></a>3.2. Vorgaben zur Verwendung von JSF</h3>
<div class="paragraph">
<p>Die folgenden Abschnitte beschreiben allgemeine Vorgaben bei der Verwendung JSF-eigener Funktionalität.</p>
</div>
<div class="sect3">
<h4 id="verwendung-von-jsf-widgets"><a class="anchor" href="#verwendung-von-jsf-widgets"></a>3.2.1. Verwendung von JSF-Widgets</h4>
<div class="paragraph">
<p>Für die Arbeit mit JSF werden gemäß dem <a href="../../../../isyfact-style-doku/latest/isy-style/styleguide.html" class="xref page">Styleguide</a> sowohl Seitenelemente als auch Bedienelemente bereitgestellt.
Seitenelemente helfen, den Seitenrahmen aufzubauen und erleichtern so einen zum Styleguide konformen Aufbau der Masken.
Bedienelemente helfen, die Masken selbst zu strukturieren und bieten vorgefertigte Widgets zur Anzeige und Eingabe von Daten.
Daneben gibt es noch einige spezielle Komponenten, z.B. um den Fokus beim Laden der Maske zu setzen oder eine Druckansicht bereitzustellen.</p>
</div>
<div class="paragraph">
<p>Die Bedienelemente sind alle als JSF Composite Components realisiert.
Dadurch ist eine einfachere Wartung möglich, da die Komponenten vollständig in XHTML definiert sind und ein Grundverständnis von JSF genügt, um Anpassungen vorzunehmen.
Spezielle Renderer oder Java-Klassen werden nicht benötigt.</p>
</div>
<div class="paragraph">
<p>Die Nutzung der durch den Styleguide definierten Elemente und durch den Baustein bereitgestellten JSF-Komponenten ist ein zentrales Thema der <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="absicherung-von-jsf-guis"><a class="anchor" href="#absicherung-von-jsf-guis"></a>3.2.2. Absicherung von JSF-GUIs</h4>
<div class="paragraph">
<p>Die Absicherung von Masken erfolgt auf Ebene des Dialogablaufs, also von Spring Web Flow.
Die Berechtigungsprüfung verwendet den Baustein Sicherheit der IsyFact.</p>
</div>
<div class="paragraph">
<p>Für die Anbindung des dort definierten <code>Berechtigungsmanager</code> an Spring Security findet die Möglichkeit zur Erstellung eines "Custom Authentication Providers" in Form des <code>WebFlowAuthenticationProvider</code> Anwendung.
Der <code>WebFlowAuthenticationProvider</code> prüft bei Bedarf, ob der Anwender die notwendigen Berechtigungen besitzt, bzw. es wird für die weitere Verarbeitung in Spring Security der notwendige Kontext aufgebaut.
<a href="#image-integration-baustein-sicherheit-klassendiagramm">Integration des Bausteins Sicherheit in Spring Security</a> zeigt die Integration des Bausteins Sicherheit in Spring Security.</p>
</div>
<div id="image-integration-baustein-sicherheit-klassendiagramm" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/integration-baustein-sicherheit-klassendiagramm.png" alt="integration baustein sicherheit klassendiagramm">
</div>
<div class="title">Abbildung 6. Integration des Bausteins Sicherheit in Spring Security</div>
</div>
<div class="paragraph">
<p><a href="#image-integration-baustein-sicherheit-sequenzdiagramm">Sequenzdiagramm Zugriff auf Sicherheitskomponente</a> stellt den Zugriff des <code>WebFlowAuthenticationProvider</code> auf den Baustein Sicherheit dar.
Hierbei werden die Rollen eines Benutzers über den Berechtigungsmanager gelesen und in einen Spring Security konformen
Token geschrieben.
Dieser Token findet dann bei der Autorisierung einzelner Benutzerinteraktion durch Spring Security Verwendung.</p>
</div>
<div id="image-integration-baustein-sicherheit-sequenzdiagramm" class="imageblock text-center">
<div class="content">
<img src="../_images/konzept/integration-baustein-sicherheit-sequenzdiagramm.png" alt="integration baustein sicherheit sequenzdiagramm">
</div>
<div class="title">Abbildung 7. Sequenzdiagramm Zugriff auf Sicherheitskomponente</div>
</div>
<div class="paragraph">
<p>Mehr Details hierzu sind in der Bausteindokumentation (<a href="../../../../isyfact-standards-doku/latest/isy-sicherheit/konzept/master.html" class="xref page">Konzept Sicherheit</a> und <a href="../../../../isyfact-standards-doku/latest/isy-sicherheit/nutzungsvorgaben/master.html" class="xref page">Nutzungsvorgaben Sicherheit</a>) sowie in den <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a> zu finden.</p>
</div>
</div>
<div class="sect3">
<h4 id="verwendung-csrf-schutz"><a class="anchor" href="#verwendung-csrf-schutz"></a>3.2.3. Verwendung des CSRF-Schutzes</h4>
<div class="paragraph">
<p>Bei einem Cross-Site Request Forgery (CSRF) Angriff versuchen die Angreifer einem angemeldeten Benutzer einen HTTP-basierten Request unterzuschieben.
Mithilfe der Session des Benutzers kann der Angreifer so Änderungen am System ausführen.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabelle 1. CSRF-Schutz je nach Schutzbedarf</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Schutzbedarf</th>
<th class="tableblock halign-left valign-top">CSRF-Schutz</th>
<th class="tableblock halign-left valign-top">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>normal</strong> und <strong>hoch</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token per Session</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Am Anfang der Benutzer-Session wird ein Token erzeugt und in der Session gespeichert. Danach wird bei jedem Request das Token mitgeschickt und mit dem in der Session gespeicherten Token abgeglichen.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sehr hoch</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token per Request</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Für jeden Request wird ein neues Token erstellt und versendet.
Das erhöht nochmals die Sicherheit, vermindert aber gleichzeitig die Benutzerfreundlichkeit, da beispielsweise ein Rücksprung zu einem Formular verhindert wird.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Weitere Details zur Konfiguration des CSRF-Schutzes stehen in <a href="../nutzungsvorgaben/nutzungsvorgaben.html" class="xref page">Nutzungsvorgaben JSF</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="parameter-mit-buttonlink-uebergeben"><a class="anchor" href="#parameter-mit-buttonlink-uebergeben"></a>3.2.4. Parameter mit Button/Link übergeben</h4>
<div class="paragraph">
<p>JSF bietet mehrere Möglichkeiten, einen Parameter in Abhängigkeit eines geklickten Buttons oder Links an die Web-Anwendung zu übergeben.
Dies ist beispielsweise dann notwendig, wenn auf einer Maske mehrere Elemente angezeigt werden, zu denen jeweils ein eigener Button zum Bearbeiten existiert.
In diesem Fall muss es möglich sein zu erkennen, welcher Button zu welchem Element geklickt worden ist.</p>
</div>
<div class="paragraph">
<p>Die hierfür in JSF 2.x vorgesehenen Lösung mit <code>f:param</code> erfordert den Einsatz von JavaScript und kann daher Probleme in der Abwärtskompatibilität hervorbringen (z.B. wenn kein JavaScript aktiviert ist).
Die Umsetzung sollte daher in der Regel mit einem Action Listener stattfinden (siehe <a href="#listing-UseActionListVIEW">Verwendung eines Action Listeners (View)</a>):</p>
</div>
<div id="listing-UseActionListVIEW" class="listingblock">
<div class="title">Listing 4. Verwendung eines Action Listeners (View)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;h:commandLink id="bearbeite_SV_#{sachverhalt.id}"
   value="#{msg.MEL_Bearbeiten}"
   actionListener="#{listener.waehleSachverhalt}"&gt;
    &lt;f:attribute name="sachverhaltId" value="#{sachverhalt.id}" /&gt;
    ...
&lt;/h:commandLink&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dabei kann in der Methode <code>waehleSachverhalt</code> der Wert des Attributs aus der <code>RequestParameterMap</code> des <code>FacesContext</code> gelesen werden (siehe <a href="#listing-EvalRequestAttr">Auswertung von Request Attributen</a>).</p>
</div>
<div id="listing-EvalRequestAttr" class="listingblock">
<div class="title">Listing 5. Auswertung von Request Attributen</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FacesContext.getCurrentInstance().getExternalContext() .getRequestParameterMap().get("sachverhaltId");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Als Alternative zum Einsatz eines Action Listeners kann die ID des Buttons/Links parametrisiert und im
Controller ausgewertet werden.
Die Parametrisierung der ID wird ebenfalls in <a href="#listing-UseActionListVIEW">Verwendung eines Action Listeners (View)</a> dargestellt.
Die Auswertung ist in diesem Fall aufwendiger, da alle Attribute der <code>RequestParameterMap</code> durchlaufen werden müssen, bis ein Parameter gefunden wurde, dessen ID mit <code>bearbeite_SV_</code> beginnt.
Vorteil der Lösung ist jedoch, dass Probleme mit dem Einsatz von Action Listenern damit umgangen werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="einsatz-von-action-listenern"><a class="anchor" href="#einsatz-von-action-listenern"></a>3.2.5. Einsatz von Action Listenern</h4>
<div class="paragraph">
<p>Aufgrund einer Eigenart von JSF in Zusammenhang mit dem Partial-State-Saving muss unbedingt darauf geachtet werden, dass die Komponente (Button/Link), an die der Action Listener gebunden ist, nicht durch den Klick ausgeblendet wird.
Andernfalls führt dies zu Problemen mit dem Loadbalancing.
Hintergrund ist, dass JSF durch das Partial-State-Saving den Zustand der Maske teilweise in der Session ablegt.
Werden die Anfragen an die Web-Anwendung durch den Loadbalancer an verschiedene Server verteilt, kann dies daher dazu führen, dass JSF einen Fehler anzeigt, weil der Action Listener der ausgeblendeten Komponente nicht gefunden werden konnte.</p>
</div>
</div>
<div class="sect3">
<h4 id="datenkonvertierung-fuer-darstellung-und-eingabe"><a class="anchor" href="#datenkonvertierung-fuer-darstellung-und-eingabe"></a>3.2.6. Konvertierung von Daten zur Darstellung und Eingabe</h4>
<div class="paragraph">
<p>JSF-Konverter dürfen sowohl zur Konvertierung aus dem Model zur View (Darstellung) als auch aus der View zum Model (Eingabe) verwendet werden.
Standard-JSF-Konverter bieten sich jedoch nur bedingt an, da diese bei der Konvertierung „freier Eingaben“ nicht mit Fehleingaben umgehen können.</p>
</div>
<div id="listing-ConvDatewihConv" class="listingblock">
<div class="title">Listing 6. Umwandlung eines Datums mittels Standard-JSF-Konverter</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;h:inputText id="datum" value="#{erstellenModel.newDate}"&gt;
       &lt;f:convertDateTime type="date" /&gt;
&lt;/h:inputText&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn die Validierung in einem Standard-JSF-Konverter stattfindet, werden die Daten in einem Fehlerfall nicht ins Modell geschrieben.
Dies führt dazu, dass das Formular zurückgesetzt wird, weil die Seite wegen des Post/Redirect/Get-Patterns mit einem GET-Request mit dem alten Modell neu geladen wird.
Die ungültigen Eingaben gehen also zusammen mit allen anderen Änderungen im Modell verloren.
Standard-JSF-Konverter sind in diesen Fällen faktisch nicht nutzbar.</p>
</div>
<div class="paragraph">
<p>JSF-Konverter müssen, um geeignet zu sein, auch ungültige Daten ins Model schreiben können.
Wenn dies aufgrund der Nutzung spezieller Datentypen (wie z.B. Datums- und Zeittypen) nicht möglich ist, muss im Model der Datentyp der Eingabe (in der Regel Zeichenketten) verwendet werden.
Die Konvertierung findet in diesem Fall nicht durch einen Konverter statt, sondern erst während oder nach der Validierung an der Schnittstelle zum <a href="../../../../glossary/latest/glossary/master.html#glossar-anwendungskern" class="xref page">Anwendungskern</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="serverseitige-validierung-von-eingaben"><a class="anchor" href="#serverseitige-validierung-von-eingaben"></a>3.2.7. Serverseitige Validierung von Eingaben</h4>
<div class="paragraph">
<p>Die Validierung und Prüfung der in der GUI erfassten Daten soll entweder vollständig durch die GUI oder aber vollständig im <a href="../../../../glossary/latest/glossary/master.html#glossar-anwendungskern" class="xref page">Anwendungskern</a> durchgeführt werden.
Die Validierung in der GUI ist dabei bevorzugt.
In diesem Falle wird der Validierungsmechanismus von Spring Web Flow verwendet (s. Abschnitt 5.10 in der Dokumentation des <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-jsf-wiki" class="xref page">JavaServer Faces</a>, <a href="../../../../glossary/latest/literaturextern/inhalt.html#litextern-swf" class="xref page">Spring Web Flows</a> ).
Standard-JSF-Validatoren oder -Konverter sollten für die Validierung aus den im Abschnitt <a href="#datenkonvertierung-fuer-darstellung-und-eingabe">Konvertierung von Daten zur Darstellung und Eingabe</a> genannten Gründen nicht verwendet werden.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vorgaben-javascript"><a class="anchor" href="#vorgaben-javascript"></a>3.3. Vorgaben zur Verwendung von JavaScript</h3>
<div class="paragraph">
<p>Bei der Verwendung von JavaScript sind grundsätzlich die folgenden Vorgaben einzuhalten:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>eval()</code> <strong>darf nicht verwendet werden</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Die Verwendung von <code>eval()</code> stellt ein Sicherheitsrisiko dar. Es besteht z.B. die Gefahr, dass Werte aus Request-Parametern ohne ausreichende Prüfung als Code ausgeführt werden.</p>
</div>
<div class="paragraph">
<p><strong>Beispiel:</strong> Der Inhalt des Strings <code>requestValue</code> wird ohne ausreichende Prüfung ausgeführt.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>var requestValue = getParameterValue(“searchString“);
eval(requestValue)</pre>
</div>
</div>
<div class="paragraph">
<p>Dies ermöglicht es jeden beliebigen JavaScript Code per Injektion auf einem Client ausführen zu lassen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>www.mySite.de?searchString=alert(‚hallo‘)</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Lösung:</strong> Anstatt Request-Parametern an die <code>eval()</code>-Funktion zu übergeben, müssen diese über eine eigene Parser-Funktion ausgewertet werden.
Die Funktion muss sicherstellen, dass kein Angriff möglich ist.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>setTimeout()</code> <strong>darf keine Funktion als Zeichenkette übergeben werden</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Die Verwendung einer Zeichenkette ermöglicht Manipulationen, falls Parameter ungeprüft übergeben und somit als Code ausgeführt werden.</p>
</div>
<div class="paragraph">
<p><strong>Beispiel:</strong> Hier wird der Code unzulässigerweise als Zeichenfolge übergeben.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setTimeout(“callFunction(searchString)“, 100);</pre>
</div>
</div>
<div class="paragraph">
<p>Ein Angreifer könnte nun eine URL wie folgt aufrufen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>www.mySite.de?searchString=5);alert(‚hallo‘</pre>
</div>
</div>
<div class="paragraph">
<p>Der Inhalt der Variable <code>searchString</code> wird ersetzt, sodass folgender Code ausgeführt wird:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setTimeout(“callFunction(5);alert(‚hallo‘)", 100);</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Lösung:</strong> Anstatt den Code in einer Zeichenfolge zu übergeben, muss eine Funktion als Parameter übergeben werden:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setTimeout(function() { ... }, 100)</pre>
</div>
</div>
<div class="paragraph">
<p>Hierdurch wird der Angriff abgewehrt.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Nutzung von anonymen Funktionen anstatt benannter Funktionen</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Definierte JavaScript-Funktionen sind in der Regel im globalen Variablen-Kontext gültig.
Würde insbesondere für jede Callback-Funktion (z.B. beim Event Binding) eine eigene Funktion definiert, würde das den Speicher unnötig belasten.
Weiterhin verschlechtert sich die Lesbarkeit.
Gerade bei Callbacks ist es nützlich, wenn direkt ersichtlich ist, was passiert, wenn der Callback aufgerufen wird.
Sofern keine Wiederverwendung möglich ist, ist daher von der Definition benannter Funktionen abzusehen.</p>
</div>
<div class="paragraph">
<p>Anonyme Funktionen können außerdem auf Variablen der umgebenden Funktion zugreifen, was die Implementierung vereinfacht:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>var einWert = 5;
setTimeout(function() { alert(4 + einWert); }, 100);</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Benannte Funktionen sollten in Namespaces deklariert werden</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Wie bereits beschrieben, gelten Funktionen häufig im globalen Kontext.
Funktionen können, wie Variablen, durch redundante Deklaration leicht überschrieben werden.
Dann gilt immer die letzte Definition.
Die Verwendung von z.B. des View-Names als „Namespace“ vermeidet, Funktionen aus einem anderen View versehentlich zu überschreiben:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>var ns_&lt;view&gt; = { foo : function() { ... } }</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Nutzung einer anonymen Funktion zur Kapselung</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Jede JavaScript-Datei beginnt mit einer <code>function()</code>-Definition.
Mit diesem Konstrukt wird verhindert, dass die Definition neuer Funktionen und Variablen (versehentlich) Elemente aus dem globalen Kontext überschreiben.
Die Deklaration von wiederverwendbaren Funktion- bzw. Namespace-Definitionen muss außerhalb dieser <code>function()</code> erfolgen.</p>
</div>
<div class="paragraph">
<p>Jede JavaScript Datei beginnt demnach mit:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(function(){</pre>
</div>
</div>
<div class="paragraph">
<p>und endet vor der Deklaration von wiederverwendbaren Funktionen bzw. Namespaces mit:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>})()</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Inline-JavaScript ist zu vermeiden</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Es gibt Fälle, in denen JavaScript „inline“ technisch bedingt direkt in der XHTML-View-Definition implementiert werden muss.
Hier besteht die Gefahr, dass der JavaScript-Code schlecht strukturiert und auf zu viele Dateien verteilt wird.
Zudem ist JavaScript-Code in XHTML-Dateien unerwartet und wird bei der Analyse der Anwendung schnell übersehen.
Insgesamt wird hierdurch die Verständlichkeit und Wartbarkeit der Anwendung verschlechtert.</p>
</div>
<div class="paragraph">
<p>Eine Implikation dieser Regel ist, dass Event-Binding stets im Code selbst und nicht in den <code>on&lt;Event&gt;</code>-Attributen der HTML-Elemente geschehen muss.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>DOM-Zugriff mit der $-Funktion nur über IDs</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Der DOM-Zugriff mit der $-Funktion sollte stets über die ID oder Klasse eines DOM-Knotens erfolgen, nicht über die Knotenhierarchie des DOMs.
Die Gefahr beim Negativ-Beispiel ist die mangelnde Robustheit bzgl. Änderungen der DOM-Struktur.
Wird z.B. ein weiterer Knoten eingefügt, greift die Funktion ggf. nicht und die Anwendung arbeitet fehlerhaft.</p>
</div>
<div class="paragraph">
<p><strong>Beispiel:</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>$(„#eineBildID“); // GUT
$(„div span a img“); // SCHLECHT</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Alle Parameter müssen korrekt encodiert und escaped werden</strong></p>
</div>
<div class="paragraph">
<p><strong>Begründung:</strong> Im JavaScript-Code dürfen Request- oder URL-Parameter nur nach ausreichendem Encodieren und Escapen verwendet werden.
Gleiches gilt für den Einsatz von Server-Parametern bzw. Model-Attributen.
Geschieht dies nicht, besteht das Sicherheitsrisiko von Ausführung von beliebigem Code (z.B. durch Request-Strings übergeben) auf dem Server.</p>
</div>
<div class="paragraph">
<p><strong>Negativ-Beispiel:</strong>
Wird beispielsweise ein Suchstring wie folgt in die Seite eingebunden:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;title&gt;${searchString}&lt;/title&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>dann könnte ein Angreifer folgende URL aufrufen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>www.mySite.de?searchString=&lt;script&gt;alert(‚halloWelt‘)&lt;/script&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Der übergebene JavaScript-Block würde dann auf dem Server ausgeführt.
Das Escapen „zerstört“ die spitzen Klammern und Hochkommata, sodass kein Code ausgeführt wird.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="clientseitige-validierung-von-eingaben"><a class="anchor" href="#clientseitige-validierung-von-eingaben"></a>3.3.1. Clientseitige Validierung von Eingaben</h4>
<div class="paragraph">
<p>Clientseitige Validierung ist erlaubt und darf zur Verbesserung der Benutzbarkeit verwendet werden.
Da JavaScript deaktivierbar und manipulierbar ist, müssen grundsätzlich alle clientseitigen Validierungen auf dem Server erneut erfolgen.</p>
</div>
</div>
<div class="sect3">
<h4 id="vermeidung-von-sicherheitsluecken-bei-aktiviertem-javascript"><a class="anchor" href="#vermeidung-von-sicherheitsluecken-bei-aktiviertem-javascript"></a>3.3.2. Vermeidung von Sicherheitslücken bei aktiviertem JavaScript</h4>
<div class="paragraph">
<p>Ist JavaScript in einem Browser aktiviert, eröffnet dies gewisse Risiken bei der Verarbeitung schützenswerter Informationen.
Folgende Maßnahmen reduzieren jedoch das Risiko möglicher Attacken für Cross-site-Scripting (XSS):</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Verwendung von Standardbrowsern</dt>
<dd>
<p>Die gängigen Browser befolgen festgelegte Sicherheitsrichtlinien, die nur schwer und
vorsätzlich deaktiviert werden können.
Diese Standard­einstellungen erschweren XSS und sind gerade für den folgenden Punkt unerlässlich.</p>
</dd>
<dt class="hdlist1">Übertragung aller Inhalte per HTTPS zum Browser</dt>
<dd>
<p>Werden Webinhalte per HTTPS zum Client übertragen, ist ein unerwünschtes
Datenauslesen per JavaScript-Injection oder IFrame-Injection verhindert, da Browser JavaScript-Code nur dann auf einen
domain-fremden DOM zugreifen lassen, sofern dieser nicht sicher übertragen wurde.</p>
</dd>
<dt class="hdlist1">Keine Verwendung von Request-Variablen in offenem JS</dt>
<dd>
<p>Werden Request-Parameter, z.B. als Teile eines Formulars,
direkt in offenem JavaScript (<code>eval([var])</code> oder <code>setTimeout([var])</code>) weiterverwendet, so können Angreifer manipulierte
Parameter für DOM-based-XSS nutzen, d.h. es werden JavaScript Befehle als Parameter übergeben, die Inhalte verändern,
auslesen oder in einen falschen Kontext setzen.</p>
</dd>
<dt class="hdlist1">Encodierung von Request-Variablen im DOM</dt>
<dd>
<p>Werden Request-Variablen auf einer Seite dargestellt, so sind diese
XML-encodiert einzubinden (siehe Element <code>outputText</code> in Kapitel <a href="#datenkonvertierung-fuer-darstellung-und-eingabe">Konvertierung von Daten zur Darstellung und Eingabe</a>).
Somit wird verhindert, dass ein Angreifer ein unerwünschtes Script-Tag übergibt.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="session-behandlung"><a class="anchor" href="#session-behandlung"></a>3.4. Session Behandlung</h3>
<div class="paragraph">
<p>Die nachfolgenden Kapitel beschäftigen sich mit der Behandlung der Session Informationen, welche in Spring Web Flow anfallen.
Hierunter fallen alle Daten, die für die Dialogabläufe benötigt werden:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Komponentenbaum der Dialogansicht, dieser beinhaltet die Dialogelemente und die Information über die Bindung an die Backing Beans.</p>
</li>
<li>
<p>Den Flow Container, in welchem die Backing Beans während dem Dialogfluss vorgehalten werden.</p>
</li>
<li>
<p>Die Conversation, welche eine Benutzerinteraktion beinhaltet, bündelt die beiden vorangegangenen Angaben.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Standardmäßig wird diese Information in der HTTP-Session abgelegt und wieder hergestellt.
Nach IsyFact-Zielarchitektur erfolgt diese Speicherung in der Datenbank.</p>
</div>
<div class="sect3">
<h4 id="session-zugriff"><a class="anchor" href="#session-zugriff"></a>3.4.1. Session Zugriff</h4>
<div class="paragraph">
<p>Für die Arbeit mit Spring Web Flow ist es notwendig, die in der Session notwendigen Daten der Conversation für
jeden Schritt bereitzustellen und nach jedem Schritt abzulegen.
Hierfür werden die Daten in der Datenbank persistiert.</p>
</div>
<div class="paragraph">
<p>Dies erfolgt über einen eigenen Session-Manager.
Als Session-Manager wird die Bibliothek <code>isy-session</code> verwendet, die eine vereinfachte
Konfiguration von <code>Spring Session</code> (der eigentlichen Implementierung des Session-Managers)
ermöglicht. <code>isy-session</code> kapselt und vereinfacht die Nutzung von <code>Spring-Session</code>.</p>
</div>
<div class="paragraph">
<p>Weitere Erläuterungen zum Session-Manager finden sich im dazugehörigen <code>Konzept Session Management</code>. Die Einbindung des Session-Managements ist in den <code>Nutzungsvorgaben isy-session</code> beschrieben. Konkrete Anweisungen zum Aufbau des Session-Speichers finden sich in den <code>Nutzungsvorgaben Redis</code>.</p>
</div>
<div class="paragraph">
<p>Wenn <code>ìsy-session</code> als Erweiterung der IsyFact nicht eingesetzt wird, muss die Session-Persistierung auf andere Weise durchgeführt
werden, wobei sicherzustellen ist, dass die Requests eines Benutzers immer auf die gleiche
Instanz gehen (Sticky Sessions). Die Session-Daten müssen dabei möglichst klein gehalten werden, um
die Performance der Anwendung nicht zu verschlechtern.</p>
</div>
<div class="paragraph">
<p>Die Größe der Session wird maßgeblich durch die „im Webflow“ gespeicherten Model-Daten bestimmt.
Daher muss darauf geachtet werden, nur unbedingt notwendige Daten im Model zu halten.</p>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<div class="divFooter"></div>

<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/isyfact.js"></script>
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../_/js/vendor/lunr-languages.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
  </body>
</html>
